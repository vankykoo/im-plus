# IM Plus 即时通讯系统 H5 开发文档

## 1. 项目概述
### 1.1 项目简介
IM Plus 是一个高性能、高可靠的即时通讯系统，采用微服务架构设计，支持私聊、群聊、多协议连接等核心功能。本文档为H5前端开发人员提供完整的开发指南。

### 1.2 核心特性
- **推拉结合传输模式**: 私聊写扩散 + 群聊读扩散，兼顾性能与存储效率
- **统一消息表设计**: 私聊、群聊消息统一存储，简化数据模型
- **混合扩散策略**: 根据群组规模动态选择扩散模式
- **双重确认机制**: 发送回执 + 接收ACK，确保消息可靠投递
- **会话级串行化处理**: 保证同一会话消息严格顺序性
- **消息分离架构**: ACK消息与业务消息分离处理

### 1.3 系统架构
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   H5客户端   │────│  网关服务    │────│  消息服务    │
│             │    │ (Gateway)   │    │ (Message)   │
└─────────────┘    └─────────────┘    └─────────────┘
                           │                   │
                           │                   │
                   ┌─────────────┐    ┌─────────────┐
                   │   用户服务   │    │  序列号服务  │
                   │   (User)    │    │ (Sequence)  │
                   └─────────────┘    └─────────────┘
```

## 2. 技术栈说明

### 2.1 推荐前端技术栈

#### 核心框架
- **Vue.js 3** 或 **React 18**: 现代化前端框架
- **TypeScript**: 类型安全，提升开发效率
- **Vite**: 快速构建工具

#### UI组件库
- **移动端**: Vant 4.x (Vue) 或 Ant Design Mobile (React)
- **桌面端**: Element Plus (Vue) 或 Ant Design (React)

#### 状态管理
- **Vue**: Pinia
- **React**: Redux Toolkit + RTK Query

#### 实时通讯
- **WebSocket**: 原生WebSocket API
- **协议**: Protocol Buffers (protobuf)

#### 数据持久化
- **localStorage/sessionStorage**: 用户信息、会话列表
- **IndexedDB**: 消息历史、离线数据

### 2.2 后端技术栈
- **Spring Boot 2.7.x**: 微服务框架
- **Spring Cloud**: 服务治理
- **Netty**: 高性能网络通信
- **MySQL 8.0**: 主数据库
- **Redis 6.x**: 缓存和会话存储
- **RocketMQ**: 消息队列
- **Protocol Buffers**: 消息序列化

## 3. 目录结构说明

### 3.1 推荐H5项目结构
```
im-h5-client/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── api/                    # API接口封装
│   │   ├── user.ts            # 用户相关接口
│   │   ├── message.ts         # 消息相关接口
│   │   └── websocket.ts       # WebSocket封装
│   ├── components/            # 通用组件
│   │   ├── ChatInput/         # 聊天输入框
│   │   ├── MessageList/       # 消息列表
│   │   └── ConversationList/  # 会话列表
│   ├── views/                 # 页面组件
│   │   ├── Login/            # 登录页面
│   │   ├── Chat/             # 聊天页面
│   │   └── Contacts/         # 联系人页面
│   ├── store/                # 状态管理
│   │   ├── user.ts           # 用户状态
│   │   ├── message.ts        # 消息状态
│   │   └── conversation.ts   # 会话状态
│   ├── utils/                # 工具函数
│   │   ├── websocket.ts      # WebSocket工具
│   │   ├── storage.ts        # 存储工具
│   │   └── protobuf.ts       # Protobuf工具
│   ├── types/                # TypeScript类型定义
│   │   ├── user.ts
│   │   ├── message.ts
│   │   └── api.ts
│   ├── App.vue               # 根组件
│   └── main.ts               # 入口文件
├── package.json
├── vite.config.ts
├── tsconfig.json
└── README.md
```

### 3.2 后端服务结构
```
im-plus/
├── im-gateway/               # 网关服务 (端口: 8080, WebSocket: 8902)
├── im-user/                  # 用户服务 (端口: 8090)
├── im-message-server/        # 消息服务 (端口: 8100)
├── im-sequence/              # 序列号服务 (端口: 8084)
├── im-common/                # 公共模块
└── im-client/                # 测试客户端
```

## 4. 开发环境配置指南

### 4.1 环境要求
- **Node.js**: >= 16.0.0
- **npm**: >= 8.0.0 或 **yarn**: >= 1.22.0
- **现代浏览器**: Chrome 88+, Firefox 85+, Safari 14+

### 4.2 项目初始化

#### 使用Vite + Vue3 + TypeScript
```bash
# 创建项目
npm create vue@latest im-h5-client
cd im-h5-client

# 安装依赖
npm install

# 安装额外依赖
npm install vant @vant/touch-emulator
npm install pinia
npm install axios
npm install protobufjs
```

#### 使用Vite + React + TypeScript
```bash
# 创建项目
npm create vite@latest im-h5-client -- --template react-ts
cd im-h5-client

# 安装依赖
npm install

# 安装额外依赖
npm install antd-mobile
npm install @reduxjs/toolkit react-redux
npm install axios
npm install protobufjs
```

### 4.3 开发服务器配置

#### vite.config.ts
```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue' // 或 react()

export default defineConfig({
  plugins: [vue()],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },
  define: {
    __WS_URL__: JSON.stringify('ws://localhost:8902/websocket')
  }
})
```

## 5. 构建与部署流程

### 5.1 开发环境
```bash
# 启动开发服务器
npm run dev

# 代码检查
npm run lint

# 类型检查
npm run type-check
```

### 5.2 生产构建
```bash
# 构建生产版本
npm run build

# 预览构建结果
npm run preview
```

### 5.3 部署配置

#### Nginx配置示例
```nginx
server {
    listen 80;
    server_name your-domain.com;
    
    root /var/www/im-h5-client/dist;
    index index.html;
    
    # SPA路由支持
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    # API代理
    location /api/ {
        proxy_pass http://localhost:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # WebSocket代理
    location /websocket {
        proxy_pass http://localhost:8902;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }
}
```

## 6. API接口文档

### 6.1 服务端点
- **网关服务**: `http://localhost:8080`
- **用户服务**: `http://localhost:8090`
- **消息服务**: `http://localhost:8100`
- **序列号服务**: `http://localhost:8084`
- **WebSocket**: `ws://localhost:8902/websocket`

### 6.2 用户相关接口

#### 用户注册
```http
POST /users/register
Content-Type: application/json

{
  "userId": "string",
  "username": "string",
  "password": "string"
}
```

**响应示例**:
```json
{
  "code": 200,
  "message": "success",
  "data": "用户ID"
}
```

#### 用户登录
```http
POST /users/login
Content-Type: application/json

{
  "userId": "string",
  "password": "string"
}
```

**响应示例**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "userId": "string",
    "username": "string",
    "token": "jwt_token",
    "expiresIn": 3600
  }
}
```

#### 获取用户信息
```http
GET /users/info/{userId}
Authorization: Bearer {token}
```

#### 获取用户在线状态
```http
GET /users/status/{userId}
Authorization: Bearer {token}
```

#### 获取用户昵称
```http
GET /users/username/{userId}
Authorization: Bearer {token}
```

#### 用户退出登录
```http
GET /users/logout/{userId}
Authorization: Bearer {token}
```

#### 查询好友关系
```http
GET /users/friendship?userId1={userId1}&userId2={userId2}
Authorization: Bearer {token}
```

#### 检查是否为好友
```http
GET /users/friendship/check?userId1={userId1}&userId2={userId2}
Authorization: Bearer {token}
```

### 6.3 消息相关接口

#### 拉取消息 (POST)
```http
POST /api/messages/pull
Content-Type: application/json
Authorization: Bearer {token}

{
  "conversationId": "string",
  "startSeq": 0,
  "endSeq": 100,
  "limit": 20
}
```

#### 拉取消息 (GET)
```http
GET /api/messages/pull?conversationId={id}&startSeq={seq}&endSeq={seq}&limit={limit}
Authorization: Bearer {token}
```

**响应示例**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "messages": [
      {
        "uid": "string",
        "type": 3001,
        "content": "string",
        "fromId": "string",
        "toId": "string",
        "conversationId": "string",
        "timestamp": 1640995200000,
        "userSeq": 1,
        "conversationSeq": 1
      }
    ],
    "hasMore": true,
    "nextSeq": 101
  }
}
```

#### 会话同步
```http
POST /api/conversations/sync
Content-Type: application/json
Authorization: Bearer {token}

{
  "userId": "string",
  "lastSyncTime": 1640995200000
}
```

#### 创建群聊
```http
POST /api/conversations/create
Content-Type: application/json
Authorization: Bearer {token}

{
    "conversationName": "string",
    "conversationDesc": "string",
    "creatorId": "string",
    "members": ["string"]
}
```

#### 获取会话最大序列号
```http
GET /api/message/max-seq/conversation/{conversationId}
Authorization: Bearer {token}
```

#### 获取用户最大序列号
```http
GET /api/message/max-seq/user/{userId}
Authorization: Bearer {token}
```

### 6.4 序列号服务接口

#### 获取单个序列号
```http
POST /api/sequence/next
Content-Type: application/json

{
  "key": "string"
}
```

#### 批量获取序列号
```http
POST /api/sequence/next-batch
Content-Type: application/json

{
  "keys": ["string"],
  "count": 10
}
```

#### 健康检查
```http
GET /api/sequence/health
```

#### 获取统计信息
```http
GET /api/sequence/stats
```

#### Ping服务
```http
GET /api/sequence/ping
```

### 6.5 通用响应格式

#### 成功响应
```json
{
  "code": 200,
  "message": "success",
  "data": {}
}
```

#### 错误响应
```json
{
  "code": 400,
  "message": "错误描述",
  "data": null
}
```

#### 常见错误码
- `200`: 成功
- `400`: 请求参数错误
- `401`: 未授权
- `403`: 禁止访问
- `404`: 资源不存在
- `500`: 服务器内部错误

## 7. WebSocket协议文档

### 7.1 连接建立

#### 连接地址
```
ws://localhost:8902/websocket
```

#### 连接参数
- 连接建立后需要发送登录消息进行身份验证
- 使用Protocol Buffers进行消息序列化

### 7.2 消息格式 (ChatMessage)

#### Protobuf定义
```protobuf
syntax = "proto3";

message ChatMessage {
  int32 type = 1;                    // 协议类型
  string content = 2;                // 消息内容
  string fromId = 3;                 // 发送方ID
  string toId = 4;                   // 接收方ID
  string uid = 5;                    // 全局唯一ID
  string seq = 6;                    // 客户端消息ID
  int64 timestamp = 7;               // 时间戳
  int32 retry = 8;                   // 重试次数
  string token = 9;                  // 身份验证token
  string conversationId = 10;        // 会话ID
  string clientSeq = 11;             // 客户端临时序列号
  int64 userSeq = 14;                // 用户级全局序列号
  int64 conversationSeq = 15;        // 会话级序列号
  int64 expectedSeq = 16;            // 期望的下一个序列号
  ReadReceipt readReceipt = 17;      // 已读回执
  ReadNotification readNotification = 18; // 已读通知
}

message ReadReceipt {
  string conversationId = 1;         // 会话ID
  int64 readSeq = 2;                 // 已读序列号
}

message ReadNotification {
  string conversationId = 1;         // 会话ID
  string userId = 2;                 // 已读用户ID
  int64 readSeq = 3;                 // 已读序列号
  int64 timestamp = 4;               // 已读时间戳
}
```

### 7.3 消息类型常量

#### 系统消息 (1000-1999)
```typescript
const MessageType = {
  // 连接相关
  LOGIN: 1000,                    // 登录消息
  LOGIN_RESPONSE: 1001,           // 登录响应
  KICKOUT_NOTIFICATION: 1002,     // 踢出通知
  
  // 心跳相关
  HEARTBEAT: 2000,                // 心跳请求
  HEARTBEAT_RESPONSE: 1003,       // 心跳响应
  
  // 系统通知
  SYSTEM_NOTIFICATION: 1004,      // 系统通知
  MESSAGE_DELIVERY_SUCCESS: 1005, // 消息投递成功
  MESSAGE_DELIVERY_FAILED: 1006,  // 消息投递失败
  GROUP_MESSAGE_NOTIFICATION: 1007, // 群聊消息通知
  MESSAGE_READ_NOTIFICATION: 1008,  // 消息已读通知
} as const
```

#### 业务消息 (3000-3999)
```typescript
const MessageType = {
  PRIVATE_CHAT_MESSAGE: 3001,     // 私聊消息
  GROUP_CHAT_MESSAGE: 3002,       // 群聊消息
} as const
```

#### 确认消息 (2000-2999)
```typescript
const MessageType = {
  HEARTBEAT: 2000,                // 心跳消息
  MESSAGE_ACK: 2001,              // 消息ACK确认
  GROUP_MESSAGE_ACK: 2002,        // 群聊消息ACK
  MESSAGE_SEND_RECEIPT: 2003,     // 消息发送回执
  CONVERSATION_ACK: 2004,         // 会话ACK
  GROUP_CONVERSATION_ACK: 2005,   // 群聊会话ACK
  SYNC_CONVERSATION_ACK: 2006,    // 同步会话ACK
  MESSAGE_READ_RECEIPT: 2008,     // 消息已读回执
} as const
```

### 7.4 连接流程

#### 1. 建立WebSocket连接
```typescript
const ws = new WebSocket('ws://localhost:8902/websocket')
```

#### 2. 发送登录消息
```typescript
const loginMessage = {
  type: 1000, // LOGIN
  fromId: userId,
  token: jwtToken,
  timestamp: Date.now(),
  uid: generateUUID(),
  seq: Date.now().toString()
}

// 使用protobuf序列化后发送
const buffer = ChatMessage.encode(loginMessage).finish()
ws.send(buffer)
```

#### 3. 处理登录响应
```typescript
ws.onmessage = (event) => {
  const buffer = new Uint8Array(event.data)
  const message = ChatMessage.decode(buffer)
  
  if (message.type === 1001) { // LOGIN_RESPONSE
    if (message.content === 'success') {
      console.log('登录成功')
      startHeartbeat()
    } else {
      console.error('登录失败:', message.content)
    }
  }
}
```

### 7.5 心跳机制

#### 心跳发送 (每30秒)
```typescript
function sendHeartbeat() {
  const heartbeatMessage = {
    type: 2000, // HEARTBEAT
    content: 'heartbeat',
    fromId: userId,
    toId: 'system',
    uid: generateUUID(),
    seq: Date.now().toString(),
    timestamp: Date.now(),
    retry: 0
  }
  
  const buffer = ChatMessage.encode(heartbeatMessage).finish()
  ws.send(buffer)
}

// 启动心跳定时器
setInterval(sendHeartbeat, 30000)
```

### 7.6 消息发送

#### 私聊消息
```typescript
function sendPrivateMessage(toUserId: string, content: string) {
  const message = {
    type: 3001, // PRIVATE_CHAT_MESSAGE
    content: content,
    fromId: userId,
    toId: toUserId,
    uid: generateUUID(),
    seq: Date.now().toString(),
    timestamp: Date.now(),
    conversationId: generateConversationId(userId, toUserId), // private_小ID_大ID
    clientSeq: generateUUID(), // 用于回执匹配
    retry: 0
  }
  
  const buffer = ChatMessage.encode(message).finish()
  ws.send(buffer)
}
```

#### 群聊消息
```typescript
function sendGroupMessage(groupId: string, content: string) {
  const message = {
    type: 3002, // GROUP_CHAT_MESSAGE
    content: content,
    fromId: userId,
    toId: groupId,
    uid: generateUUID(),
    seq: Date.now().toString(),
    timestamp: Date.now(),
    conversationId: `group_${groupId}`,
    clientSeq: generateUUID(),
    retry: 0
  }
  
  const buffer = ChatMessage.encode(message).finish()
  ws.send(buffer)
}
```

### 7.7 消息接收处理

```typescript
ws.onmessage = (event) => {
  const buffer = new Uint8Array(event.data)
  const message = ChatMessage.decode(buffer)
  
  switch (message.type) {
    case 3001: // 私聊消息
      handlePrivateMessage(message)
      sendMessageAck(message) // 发送ACK确认
      break
      
    case 1007: // 群聊消息通知
      handleGroupMessageNotification(message)
      sendGroupConversationAck(message)
      break
      
    case 2003: // 消息发送回执
      handleMessageSendReceipt(message)
      break
      
    case 1008: // 消息已读通知
      handleMessageReadNotification(message)
      break
      
    case 1003: // 心跳响应
      console.log('心跳响应正常')
      break
  }
}
```

### 7.8 消息确认机制

#### 发送消息ACK
```typescript
function sendMessageAck(originalMessage: ChatMessage) {
  const ackMessage = {
    type: 2001, // MESSAGE_ACK
    content: 'ack',
    fromId: userId,
    toId: originalMessage.fromId,
    uid: originalMessage.uid, // 使用原消息的UID
    seq: originalMessage.seq,
    timestamp: Date.now(),
    conversationId: originalMessage.conversationId,
    retry: 0
  }
  
  const buffer = ChatMessage.encode(ackMessage).finish()
  ws.send(buffer)
}
```

### 7.9 会话ID规则

#### 私聊会话ID
```typescript
function generatePrivateConversationId(userId1: string, userId2: string): string {
  const sortedIds = [userId1, userId2].sort()
  return `private_${sortedIds[0]}_${sortedIds[1]}`
}
```

#### 群聊会话ID
```typescript
function generateGroupConversationId(groupId: string): string {
  return `group_${groupId}`
}
```

## 8. 代码规范要求

### 8.1 TypeScript规范

#### 类型定义
```typescript
// 用户信息类型
interface User {
  userId: string
  username: string
  avatar?: string
  status: 'online' | 'offline' | 'away'
}

// 消息类型
interface Message {
  uid: string
  type: number
  content: string
  fromId: string
  toId: string
  conversationId: string
  timestamp: number
  userSeq?: number
  conversationSeq?: number
}

// API响应类型
interface ApiResponse<T = any> {
  code: number
  message: string
  data: T
}
```

#### 接口封装
```typescript
// api/user.ts
import axios from 'axios'

const userApi = {
  async login(username: string, password: string): Promise<ApiResponse<LoginResponse>> {
    const response = await axios.post('/users/login', { username, password })
    return response.data
  },
  
  async getUserInfo(userId: string): Promise<ApiResponse<User>> {
    const response = await axios.get(`/users/info/${userId}`)
    return response.data
  }
}

export default userApi
```

### 8.2 WebSocket封装

```typescript
// utils/websocket.ts
import { ChatMessage } from '../types/message'

class WebSocketManager {
  private ws: WebSocket | null = null
  private heartbeatTimer: number | null = null
  private reconnectTimer: number | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  
  constructor(
    private url: string,
    private onMessage: (message: ChatMessage) => void,
    private onConnect: () => void,
    private onDisconnect: () => void
  ) {}
  
  connect(token: string, userId: string): void {
    try {
      this.ws = new WebSocket(this.url)
      this.ws.binaryType = 'arraybuffer'
      
      this.ws.onopen = () => {
        console.log('WebSocket连接已建立')
        this.sendLoginMessage(token, userId)
        this.startHeartbeat()
        this.reconnectAttempts = 0
        this.onConnect()
      }
      
      this.ws.onmessage = (event) => {
        const buffer = new Uint8Array(event.data)
        const message = ChatMessage.decode(buffer)
        this.onMessage(message)
      }
      
      this.ws.onclose = () => {
        console.log('WebSocket连接已关闭')
        this.stopHeartbeat()
        this.onDisconnect()
        this.attemptReconnect(token, userId)
      }
      
      this.ws.onerror = (error) => {
        console.error('WebSocket错误:', error)
      }
    } catch (error) {
      console.error('WebSocket连接失败:', error)
    }
  }
  
  sendMessage(message: ChatMessage): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      const buffer = ChatMessage.encode(message).finish()
      this.ws.send(buffer)
    } else {
      console.error('WebSocket未连接，无法发送消息')
    }
  }
  
  private sendLoginMessage(token: string, userId: string): void {
    const loginMessage = {
      type: 1000,
      fromId: userId,
      token: token,
      timestamp: Date.now(),
      uid: this.generateUUID(),
      seq: Date.now().toString()
    }
    this.sendMessage(loginMessage as ChatMessage)
  }
  
  private startHeartbeat(): void {
    this.heartbeatTimer = window.setInterval(() => {
      this.sendHeartbeat()
    }, 30000)
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
  }
  
  private sendHeartbeat(): void {
    const heartbeatMessage = {
      type: 2000,
      content: 'heartbeat',
      fromId: 'client',
      toId: 'system',
      uid: this.generateUUID(),
      seq: Date.now().toString(),
      timestamp: Date.now(),
      retry: 0
    }
    this.sendMessage(heartbeatMessage as ChatMessage)
  }
  
  private attemptReconnect(token: string, userId: string): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++
      const delay = Math.pow(2, this.reconnectAttempts) * 1000 // 指数退避
      
      this.reconnectTimer = window.setTimeout(() => {
        console.log(`尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})`)
        this.connect(token, userId)
      }, delay)
    } else {
      console.error('达到最大重连次数，停止重连')
    }
  }
  
  disconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }
    this.stopHeartbeat()
    if (this.ws) {
      this.ws.close()
      this.ws = null
    }
  }
  
  private generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0
      const v = c === 'x' ? r : (r & 0x3 | 0x8)
      return v.toString(16)
    })
  }
}

export default WebSocketManager
```

### 8.3 状态管理规范 (Pinia)

```typescript
// store/message.ts
import { defineStore } from 'pinia'
import { Message, Conversation } from '../types/message'

interface MessageState {
  conversations: Conversation[]
  messages: Record<string, Message[]>
  unreadCounts: Record<string, number>
}

export const useMessageStore = defineStore('message', {
  state: (): MessageState => ({
    conversations: [],
    messages: {},
    unreadCounts: {}
  }),
  
  getters: {
    getConversationMessages: (state) => (conversationId: string) => {
      return state.messages[conversationId] || []
    },
    
    getUnreadCount: (state) => (conversationId: string) => {
      return state.unreadCounts[conversationId] || 0
    }
  },
  
  actions: {
    addMessage(message: Message) {
      const { conversationId } = message
      if (!this.messages[conversationId]) {
        this.messages[conversationId] = []
      }
      this.messages[conversationId].push(message)
      
      // 更新未读计数
      if (message.fromId !== getCurrentUserId()) {
        this.unreadCounts[conversationId] = (this.unreadCounts[conversationId] || 0) + 1
      }
    },
    
    markAsRead(conversationId: string) {
      this.unreadCounts[conversationId] = 0
    },
    
    updateConversations(conversations: Conversation[]) {
      this.conversations = conversations
    }
  }
})
```

### 8.4 错误处理规范

```typescript
// utils/error-handler.ts
export class ApiError extends Error {
  constructor(
    public code: number,
    message: string,
    public data?: any
  ) {
    super(message)
    this.name = 'ApiError'
  }
}

export function handleApiError(error: any): never {
  if (error.response) {
    const { code, message } = error.response.data
    throw new ApiError(code, message, error.response.data)
  } else if (error.request) {
    throw new ApiError(0, '网络请求失败，请检查网络连接')
  } else {
    throw new ApiError(-1, error.message || '未知错误')
  }
}

// 在组件中使用
try {
  const result = await userApi.login(username, password)
  // 处理成功结果
} catch (error) {
  if (error instanceof ApiError) {
    // 显示错误信息给用户
    showErrorMessage(error.message)
  } else {
    // 处理其他类型的错误
    console.error('未知错误:', error)
  }
}
```

### 8.5 代码格式化配置

#### .eslintrc.js
```javascript
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:vue/vue3-recommended' // 或 'plugin:react/recommended'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2021,
    sourceType: 'module'
  },
  plugins: [
    '@typescript-eslint',
    'vue' // 或 'react'
  ],
  rules: {
    'indent': ['error', 2],
    'quotes': ['error', 'single'],
    'semi': ['error', 'never'],
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn'
  }
}
```

#### .prettierrc
```json
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
```

### 8.6 Git提交规范

#### 提交消息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### 类型说明
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

#### 示例
```
feat(chat): 添加消息发送功能

- 实现WebSocket消息发送
- 添加消息状态管理
- 支持文本和图片消息

Closes #123
```

---

## 附录

### A. 常用工具函数

```typescript
// utils/helpers.ts

// 生成UUID
export function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0
    const v = c === 'x' ? r : (r & 0x3 | 0x8)
    return v.toString(16)
  })
}

// 格式化时间
export function formatTime(timestamp: number): string {
  const date = new Date(timestamp)
  const now = new Date()
  const diff = now.getTime() - date.getTime()
  
  if (diff < 60000) { // 1分钟内
    return '刚刚'
  } else if (diff < 3600000) { // 1小时内
    return `${Math.floor(diff / 60000)}分钟前`
  } else if (diff < 86400000) { // 1天内
    return `${Math.floor(diff / 3600000)}小时前`
  } else {
    return date.toLocaleDateString()
  }
}

// 生成会话ID
export function generateConversationId(userId1: string, userId2: string): string {
  const sortedIds = [userId1, userId2].sort()
  return `private_${sortedIds[0]}_${sortedIds[1]}`
}

export function generateGroupConversationId(groupId: string): string {
  return `group_${groupId}`
}

// 防抖函数
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: number | null = null
  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout)
    timeout = window.setTimeout(() => func(...args), wait)
  }
}

// 节流函数
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle = false
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}
```

### B. 环境变量配置

```bash
# .env.development
VITE_API_BASE_URL=http://localhost:8080
VITE_WS_URL=ws://localhost:8902/websocket
VITE_APP_TITLE=IM Plus 开发环境

# .env.production
VITE_API_BASE_URL=https://api.yourdom.com
VITE_WS_URL=wss://ws.yourdomain.com/websocket
VITE_APP_TITLE=IM Plus
```

### C. 性能优化建议

1. **消息列表虚拟滚动**: 对于大量消息的会话，使用虚拟滚动减少DOM节点
2. **图片懒加载**: 消息中的图片使用懒加载技术
3. **消息分页**: 实现消息分页加载，避免一次性加载过多消息
4. **离线存储**: 使用IndexedDB存储消息历史，提升离线体验
5. **连接池管理**: 合理管理WebSocket连接，避免频繁重连
6. **消息去重**: 基于消息UID进行去重处理
7. **状态持久化**: 重要状态数据持久化到本地存储

---

**文档版本**: v1.0.0  
**最后更新**: 2024年1月  
**维护者**: IM Plus 开发团队

如有问题，请联系开发团队或查看项目README文档。